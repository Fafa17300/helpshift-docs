---
sidebar_position: 90
title: Helpshiftのデリゲート
description: "Helpshift SDKでは、アプリの開発者がヘルプセクション内でのユーザーアクティビティを追跡できるようにデリゲートコールバックが提供されています。"
---

import {
  Admonition,
  CodeBlock,
  Tabs,
  TabItem,
  LatestSdkVersion,
  Centered,
  Image,
  Intro,
  SideBySide,
  DownloadButton,
  Steps,
  Step,
} from "@site/src/components/forDocs";

# Helpshiftのデリゲート {#delegates}

<Intro>

Helpshift SDKでは、アプリの開発者がヘルプセクション内でのユーザーアクティビティを追跡できるようにデリゲートコールバックが提供されています。

</Intro>

<Admonition type="info" title="注意">

SDKに含まれているすべてのパブリックAPIは、[Helpshift installWithPlatformId API](/sdkx_ios/getting-started#start-using)を介してSDKを初期化した後に呼び出す必要があります

</Admonition>

## Helpshiftのデリゲート実装 {#helpshift-delegates-implementation}

Helpshiftサポートデリゲートを実装したクラスを定義し、`sharedInstance`の`delegate`プロパティを設定してそれをHelpshiftに渡す必要があります。

### 例 {#helpshift-delegate-example}

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
// Class implementation
#import <Foundation/Foundation.h>
@import HelpshiftX;

@interface MyDelegates ()<HelpshiftDelegate>
@end

@implementation MyDelegates

- (void) handleHelpshiftEvent:(NSString *)eventName withData(NSDictionary *)data {
    // your code here
}

- (void) authenticationFailedForUserWithReason(HelpshiftAuthenticationFailureReason)reason {
    // your code here
}

@end

// Class Usage
@property (strong, nonatomic) MyDelegate *delegate;
....
delegate = [[MyDelegates alloc] init];
Helpshift.sharedInstance.delegate = self;
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
import Foundation
import HelpshiftX

// Class implementation
class HelpshiftDelegateHandler: HelpshiftDelegate {
    func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
        // Your code here
    }

    func authenticationFailedForUser(with reason: HelpshiftAuthenticationFailureReason) {
        // Your code here
    }
}

// Class usage
let delegateHandler = HelpshiftDelegateHandler()
Helpshift.sharedInstance().delegate = delegateHandler
```

</TabItem>

</Tabs>

APIがデリゲートメソッドをコールバックできるように、デリゲートは必ずConversation APIを呼び出す前に設定してください。

## Helpshiftのイベント {#helpshift-delegate-events}

### 会話の状態イベント {#conversationStatus}

このイベントには、現在進行中の会話に関する情報が含まれています。

- イベントの名前: `HelpshiftEventNameConversationStatus` <br />
- イベントのデータ:
  - `HelpshiftEventDataLatestIssueId` <br />
  - `HelpshiftEventDataLatestIssuePublishId` <br />
  - `HelpshiftEventDataIsIssueOpen`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameConversationStatus]) {
        NSLog(@"Issue ID: %@", data[HelpshiftEventDataLatestIssueId]);
        NSLog(@"Publish ID: %@", data[HelpshiftEventDataLatestIssuePublishId]);
        NSLog(@"Is issue open: %@", data[HelpshiftEventDataIsIssueOpen]);
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameConversationStatus {
        guard let data = data else { return }
        let issueId = data[HelpshiftEventDataLatestIssueId]
        let publishId = data[HelpshiftEventDataLatestIssuePublishId]
        let issueOpen = data[HelpshiftEventDataIsIssueOpen]

        print("Issue id \(issueId), publishId: \(publishId), issueOpen: \(issueOpen)")
    }
}
```

</TabItem>

</Tabs>

### ウィジェットトグルイベント {#widgetToggle}

このイベントは、ユーザーがチャット画面を開いたり閉じたりしたときにトリガーされます。このイベントは、`"visible"`キーのブール値を用いてトリガーされます。ご参考までに、以下の例をご確認ください:

- イベントの名前: `HelpshiftEventNameWidgetToggle`
- イベントのデータ: `HelpshiftEventDataVisible`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameWidgetToggle]) {
        NSLog(@"Is chat screen visible: %@", data[HelpshiftEventDataVisible]);
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameWidgetToggle {
        guard let data = data else { return }
        let widgetStatus = data[HelpshiftEventDataVisible]
        print("Is chat screen visible: \(widgetStatus)")
    }
}
```

</TabItem>

</Tabs>

### 会話の開始イベント {#conversationStart}

このイベントは、ユーザーが会話の中で最初のメッセージを送信したときにトリガーされます。イベントのデータオブジェクトには`message`キーが含まれており、これにはエンドユーザーが会話を始めるために送信したメッセージの文字列が含まれています。

- イベントの名前: `HelpshiftEventNameConversationStart`
- イベントのデータ: `HelpshiftEventDataMessage`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameConversationStart]) {
        NSLog(@"Conversation started with text: %@", data[HelpshiftEventDataMessage]);
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameConversationStart {
        guard let data = data else { return }
        let messageBody = data[HelpshiftEventDataMessage]
        print("Conversation started with text: \(messageBody))")
    }
}
```

</TabItem>

</Tabs>

### メッセージの追加イベント {#messageAdd}

このイベントは、ユーザーが会話内でメッセージを追加したときにトリガーされます。追加されるメッセージには、テキストメッセージ、ボットの入力を介した応答、添付ファイルなどが想定されています。イベントのデータオブジェクトには`type`キーと`body`キーが含まれており、これらはユーザーが追加したメッセージの種類と本文を示しています。

- イベントの名前: `HelpshiftEventNameMessageAdd`
- イベントのデータ:
  - `HelpshiftEventDataMessageType`
  - `HelpshiftEventDataMessageTypeText`
  - `HelpshiftEventDataMessageTypeAttachment`
  - `HelpshiftEventDataMessageBody`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameMessageAdd]) {
        NSLog(@"New message added with body: %@", data[HelpshiftEventDataMessageBody]);
        NSLog(@"New message added with type: %@", data[HelpshiftEventDataMessageType]);
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameMessageAdd {
        guard let data = data else { return }
        let messageBody = data[HelpshiftEventDataMessageBody]
        let messageType = data[HelpshiftEventDataMessageType]
        print("Message: \(messageBody), type: \(messageType)")
    }
}
```

</TabItem>

</Tabs>

### CSATの送信イベント {#csatSubmit}

このイベントは、会話の終了後にユーザーがCSAT（顧客満足度）評価を送信したときにトリガーされます。イベントのデータオブジェクトには`rating`キーと`additionalFeedback`キーが含まれており、これらはユーザーがCSATフォームを介して提供した（星による）評価と追加のコメントを示しています。

- イベントの名前: `HelpshiftEventNameCSATSubmit`
- イベントのデータ:
  - `HelpshiftEventDataRating`
  - `HelpshiftEventDataAdditionalFeedback`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameCSATSubmit]) {
        NSLog(@"CSAT Submitted with rating: %@", data[HelpshiftEventDataRating]);
        NSLog(@"CSAT Submitted with feedback: %@", data[HelpshiftEventDataAdditionalFeedback]);
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameCSATSubmit {
        guard let data = data else { return }
        let rating = data[HelpshiftEventDataRating]
        let feedback = daat[HelpshiftEventDataAdditionalFeedback]
        print("CSAT Rating: \(rating), feedback:\(feedback))")
    }
}
```

</TabItem>

</Tabs>

### 会話の終了イベント {#conversationEnd}

このイベントは会話が終了（解決または拒否）し、再開できない場合にトリガーされます。

- イベントの名前: `HelpshiftEventNameConversationEnd`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameConversationEnd]) {
        NSLog(@"Conversation ended.");
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameConversationEnd {
        print("Conversation ended")
    }
}
```

</TabItem>

</Tabs>

### 会話の拒否イベント {#conversationRejected}

このイベントは、エージェントが会話を拒否したときにトリガーされます。

- イベントの名前: `HelpshiftEventNameConversationRejected`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameConversationRejected]) {
        NSLog(@"Conversation rejected.");
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameConversationRejected {
        print("Conversation rejected")
    }
}
```

</TabItem>

</Tabs>

### 会話の解決イベント {#conversationResolved}

このイベントは、エージェントが会話を解決したときにトリガーされます。

イベントの名前: `HelpshiftEventNameConversationResolved`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameConversationResolved]) {
        NSLog(@"Conversation resolved.");
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameConversationResolved {
        print("Conversation resolved")
    }
}
```

</TabItem>

</Tabs>

### 会話の再開イベント {#conversationReopened}

解決に関する質問が有効化されている場合、ユーザーに対して解決の内容に満足しているかどうかが質問されます。ユーザーがそれを拒否し、新しいメッセージを送信すると会話が再開され、会話の再開イベントがトリガーされます。

イベントの名前: `HelpshiftEventNameConversationReopened`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameConversationReopened]) {
        NSLog(@"Conversation reopened.");
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameConversationReopened {
        print("Conversation reopened")
    }
}
```

</TabItem>

</Tabs>

### ユーザー認証の失敗イベント {#authetication-failure}

ダッシュボードで`User Authentication`機能が有効化された状態で`Helpshift.login(userDataMap)`で無効なトークンを渡すと、理由に関する文字列とともにこのイベントを受け取ります。詳細については、[こちらを参照してください](/sdkx_ios/users)。

理由の種類:

- `HelpshiftAuthenticationFailureReasonAuthTokenNotProvided`
- `HelpshiftAuthenticationFailureReasonInvalidAuthToken`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) authenticationFailedForUserWithReason:(HelpshiftAuthenticationFailureReason)reason {
    // Handle authentication failure
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func authenticationFailedForUser(withReason reason: HelpshiftAuthenticationFailureReason) {
  // Handle authentication failure
}
```

</TabItem>

</Tabs>

### Helpshiftセッションのデリゲート {#session-delegates}

#### Helpshiftセッションの開始

Helpshiftセッションがアプリ内でいつ開始したかを追跡する場合は、このデリゲートコールバックを実装します。このデリゲートは、Helpshiftセッションが開始するたびに発動します。

- イベントの名前: `HelpshiftEventNameSessionStarted`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameSessionStarted]) {
        NSLog(@"Helpshift session started.");
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
        if eventName == HelpshiftEventNameSessionStarted {
            print("Helpshift session started.")
        }
}
```

</TabItem>

</Tabs>

#### Helpshiftセッションの終了

Helpshiftセッションがアプリ内でいつ終了したかを追跡する場合は、このデリゲートコールバックを実装します。このデリゲートは、Helpshiftセッションが終了するたびに発動します。

- イベントの名前: `HelpshiftEventNameSessionEnded`

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameSessionEnded]) {
        NSLog(@"Helpshift session ended.");
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
        if eventName == HelpshiftEventNameSessionEnded {
            print("Helpshift session ended.")
        }
}
```

</TabItem>

</Tabs>

### 未読メッセージ数の計測イベント {#unreadMessageCount}

既存の会話で受信した新規メッセージの数を計測する場合は、この`[Helpshift requestUnreadMessageCount:];`APIを呼び出します。

未読メッセージの数は、このイベントを介してアプリに伝達されます。また、このイベントを使用してバッジの表示数を更新し続けることもできます。

- イベントの名前: `HelpshiftEventDataUnreadMessageCount`
- イベントのデータ:
  - `HelpshiftEventDataUnreadMessageCount`
  - `HelpshiftEventDataUnreadMessageCountIsFromCache`

例:

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) handleHelpshiftEvent:(NSString *)eventName withData:(NSDictionary *)data {
    ...
    if([eventName isEqualToString:HelpshiftEventNameReceivedUnreadMessageCount]) {
        int count = data[HelpshiftEventDataUnreadMessageCount];
        NSLog(@"Unread count: %d", data[HelpshiftEventDataUnreadMessageCount]);
        NSLog(@"Is unreadCount served from local cache : %d", data[HelpshiftEventDataUnreadMessageCountIsFromCache]);
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func handleHelpshiftEvent(_ eventName: String, withData data: [AnyHashable : Any]?) {
    if eventName == HelpshiftEventNameReceivedUnreadMessageCount {
        guard let data = data else { return }
        let count = data[HelpshiftEventDataUnreadMessageCount] as? Int
        let isFromCache = data[HelpshiftEventDataUnreadMessageCount] as? Bool
        print("Count: \(count), fromCache: \(isFromCache)")
    }
}
```

</TabItem>

</Tabs>

`[Helpshift requestUnreadMessageCount:YES];`メソッドを呼び出すと、上記のデリゲートメソッド内のサーバーから通知の数が非同期で返されます。この通知の数は、キャッシュまたはHelpshiftサーバーのいずれかから取得されます。Helpshiftサーバーから取得する場合の通知数についてはレートが制限されており、タイムアウトのリセット後またはユーザーがチャット画面を閉じた後（いずれかの早い方）にAPIに対する次の呼び出しが行われた場合にのみ最新の値が返されます。レート制限の期間内にAPIが呼び出された場合には、ローカルキャッシュから値が返されます。タイムアウトのリセット時間は、アクティブな問題の場合は1分、そして非アクティブな問題の場合には5分に設定されています。

ローカルに保存されている現在の通知数を取得する場合、パラメータをfalseに設定した同じ`[Helpshift requestUnreadMessageCount:NO];`メソッドを呼び出します。この場合、SDKはローカルで利用可能な未読メッセージの数をこのデリゲートメソッド内で返します。

ローカルに保存されている未読メッセージの数は、追加のネットワーク呼び出しを節約するのに役立ちます。
