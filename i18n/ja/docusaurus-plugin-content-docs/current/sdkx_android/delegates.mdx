---
sidebar_position: 90
title: Helpshiftのデリゲート
description: "Helpshift SDKでは、アプリの開発者がヘルプセクション内でのユーザーアクティビティを追跡できるようにデリゲートコールバックが提供されています。"
---

import {
  Admonition,
  CodeBlock,
  Tabs,
  TabItem,
  LatestSdkVersion,
  Centered,
  Image,
  Intro,
  SideBySide,
  DownloadButton,
  Steps,
  Step,
} from "@site/src/components/forDocs";

# Helpshift のデリゲート {#delegates}

<Intro>

Helpshift SDK では、アプリの開発者がヘルプセクション内でのユーザーアクティビティを追跡できるようにデリゲートコールバックが提供されています。

</Intro>

<Admonition type="info" title="注意">

SDK に含まれているすべてのパブリック API は、[Helpshift.install() API](/sdkx_android/getting-started#start-using)を介して SDK を初期化した後に呼び出す必要があります

</Admonition>

## Helpshift イベントリスナー/デリゲートの実装 {#helpshift-delegates-implementation}

`Helpshift.setHelpshiftEventsListener()`メソッドを呼び出すことで、`HelpshiftEventsListener`を設定することができます。

<Admonition type="info" title="注意">

`Helpshift.setHelpshiftEventsListener`を設定する前に呼び出されたイベントをもう一度受信することはできません。

</Admonition>

例:

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
 @Override
 public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
   switch(eventName){
     case HelpshiftEvent.CONVERSATION_START:
       //your code here
     break;
     // and so on...
     //the list of events is given below
   }
 }

 @Override
 public void onUserAuthenticationFailure(HelpshiftAuthenticationFailureReason reason) {
   // your code here
 }
);
```

クラスの実装:
`HelpshiftEventsListener`を実装するクラスを定義し、
`Helpshift.setHelpshiftEventsListener()`メソッドを使用してこのイベントリスナーのインスタンスを設定する必要があります。

```java
class MyEventListener implements HelpshiftEventsListener{

  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_START:
        //your code here
      break;
      // and so on...
      //the list of events is given below
    }

  @Override
  public void onUserAuthenticationFailure(HelpshiftAuthenticationFailureReason reason) {
    // your code here
  }
}

MyEventListener listener = new MyEventListener();
Helpshift.setHelpshiftEventsListener(listener);
```

## Helpshift のイベント {#helpshift-events}

### 会話の状態イベント {#conversation-status}

このイベントには、現在進行中の会話に関する情報が含まれています。

- イベントの名前: `HelpshiftEvent.CONVERSATION_STATUS`
- イベントのデータ:
  - `HelpshiftEvent.DATA_LATEST_ISSUE_ID`
  - `HelpshiftEvent.DATA_LATEST_ISSUE_PUBLISH_ID`
  - `HelpshiftEvent.DATA_IS_ISSUE_OPEN`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_STATUS:
        Log.d(TAG, data.get(HelpshiftEvent.DATA_LATEST_ISSUE_PUBLISH_ID));
    }
  }
```

### ウィジェットの切り替えイベント {#widget-toggle-event}

このイベントは、ユーザーがチャット画面を開いたり閉じたりしたときにトリガーされます。このイベントは、`"visible"`キーのブーリアン値を用いてトリガーされます。

- イベントの名前: `HelpshiftEvent.WIDGET_TOGGLE`
- イベントのデータ: `HelpshiftEvent.DATA_SDK_VISIBLE`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.WIDGET_TOGGLE:
        Log.d(TAG, data.get(HelpshiftEvent.DATA_SDK_VISIBLE));
    }
  }
```

### ユーザーによるアクションをクリック時のイベント {#user-click-on-action}

このイベントは、ユーザーがアクションカードメッセージのリンクやアクションの呼び出しをクリックした時にトリガーされます。

- イベントの名前: `HelpshiftEvent.ACTION_CLICKED`
- イベントのデータ:
  - `HelpshiftEvent.DATA_ACTION `
  - `HelpshiftEvent.DATA_ACTION_TYPE `
  - `HelpshiftEvent.DATA_ACTION_TYPE_CALL `
  - `HelpshiftEvent.DATA_ACTION_TYPE_LINK `

| キー（定数）                         | キー（生）        | データ型 |
| ------------------------------------ | ----------------- | -------- |
| HelpshiftEvent.ACTION_CLICKED        | userClickOnAction | 文字列   |
| HelpshiftEvent.DATA_ACTION           | actionType        | 文字列   |
| HelpshiftEvent.DATA_ACTION_TYPE      | actionData        | 文字列   |
| HelpshiftEvent.DATA_ACTION_TYPE_CALL | call              | 文字列   |
| HelpshiftEvent.DATA_ACTION_TYPE_LINK | link              | 文字列   |

<Admonition type="info" title="注意">

キーの定数は、SDK X 10.3.0 以降で利用可能です。古いバージョンの SDK X では、生のキーを代わりに使用してください。

</Admonition>

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.ACTION_CLICKED:
          // With Key Constants
          String actionType = (String) data.get(HelpshiftEvent.DATA_ACTION_TYPE);
          String actionData = (String) data.get(HelpshiftEvent.DATA_ACTION);

          -------------------- OR --------------------

          // With Key Raw Values
          String actionType = (String) data.get("actionType");
          String actionData = (String) data.get("actionData");

          // `Utils.isEmpty` is null and empty Check
          if (Utils.isEmpty(actionType) || Utils.isEmpty(actionData)) {
            Log.d(TAG, "Event Received for " + eventName + " with actionType or action Data as empty");
            return;
          }

          Log.d(TAG, "Event Received for " + eventName + " action type " + actionType + " actionData " + actionData);
    }
  }});
```

### 会話の開始イベント {#conversation-start-event}

このイベントは、ユーザーが会話の中で最初のメッセージを送信したときにトリガーされます。イベントのデータオブジェクトには`message`キーが含まれており、これにはエンドユーザーが会話を始めるために送信したメッセージの文字列が含まれています。

- イベントの名前: `HelpshiftEvent.CONVERSATION_START`
- イベントのデータ: `HelpshiftEvent.DATA_MESSAGE`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_START:
        Log.d(TAG, data.get(HelpshiftEvent.DATA_MESSAGE));
    }
  }
```

### メッセージの追加イベント {#message-add-event}

このイベントは、ユーザーが会話内でメッセージを追加したときにトリガーされます。追加されるメッセージには、テキストメッセージ、ボットの入力を介した応答、添付ファイルなどが想定されています。イベントのデータオブジェクトには`type`キーと`body`キーが含まれており、これらはユーザーが追加したメッセージの種類と本文を示しています。

- イベントの名前: `HelpshiftEvent.MESSAGE_ADD`
- イベントのデータ:
  - `HelpshiftEvent.DATA_MESSAGE_TYPE`
  - `HelpshiftEvent.DATA_MESSAGE_BODY`
  - `HelpshiftEvent.DATA_MESSAGE_TYPE_ATTACHMENT`
  - `HelpshiftEvent.DATA_MESSAGE_TYPE_TEXT`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.MESSAGE_ADD:
        Log.d(TAG, data.get(HelpshiftEvent.DATA_MESSAGE_BODY));
        if(data.get(HelpshiftEvent.DATA_MESSAGE_TYPE).equals(HelpshiftEvent.DATA_MESSAGE_TYPE_ATTACHMENT)){
          Log.d(TAG, "user sent an attachment");
        }
    }
  }
```

### エージェントメッセージの受信イベント {#agent-message-received}

このイベントは、ユーザーが会話中にエージェントから何らかのメッセージを受信したときにトリガーされます。このデリゲートは、ボットによるメッセージや自動送信メッセージに対してはトリガーされません。

- イベントの名前: `HelpshiftEvent.AGENT_MESSAGE_RECEIVED`
- イベントのデータ:

  | キー                             | データ型                | 値                                               |
  | -------------------------------- | ----------------------- | ------------------------------------------------ |
  | HelpshiftEvent.DATA_PUBLISH_ID   | 文字列                  | 現在進行中の問題の会話 ID                        |
  | HelpshiftEvent.DATA_MESSAGE_TYPE | 文字列                  | メッセージのメッセージ型                         |
  | HelpshiftEvent.DATA_MESSAGE_BODY | 文字列                  | エージェントが送信した実際のメッセージまたは空白 |
  | HelpshiftEvent.DATA_CREATED_TIME | Long                    | ミリ秒単位の Unix エポックのタイムスタンプ       |
  | HelpshiftEvent.DATA_ATTACHMENTS  | マップ<String, Object>> | 添付ファイル（存在する場合）                     |
  | HelpshiftEvent.DATA_URL          | 文字列                  | 添付ファイルの URL                               |
  | HelpshiftEvent.DATA_CONTENT_TYPE | 文字列                  | 添付ファイルの MIME タイプ                       |
  | HelpshiftEvent.DATA_FILE_NAME    | 文字列                  | 添付ファイルのファイル名                         |
  | HelpshiftEvent.DATA_SIZE         | Integer                 | 添付ファイルのサイズ（バイト単位）               |

<Admonition type="info" title="注意">

- このデリゲートは、10.3.0 以降のバージョンで利用可能です
- 添付ファイルのキーは、エージェントが添付ファイルを送信した場合にのみ存在します。
- エージェントが送信した添付ファイルには必要な MIME タイプや名前がない可能性があるため、ペイロードから`HelpshiftEvent.DATA_CONTENT_TYPE`が欠落する可能性があります。
  そういった場合には、ファイル名の拡張子からファイルの種類を推測することができます。
- HelpshiftEvent.DATA_MESSAGE_TYPE には、以下の種類があります。
  - HelpshiftEvent.DATA_MESSAGE_TYPE_APP_REVIEW_REQUEST
  - HelpshiftEvent.DATA_MESSAGE_TYPE_SCREENSHOT_REQUEST
  - HelpshiftEvent.DATA_MESSAGE_TYPE_TEXT

</Admonition>

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> eventData) {
        switch (eventName) {
          case HelpshiftEvent.AGENT_MESSAGE_RECEIVED:
            Log.d(TAG,"Received Event for " + eventName);
            String publishId = (String) eventData.get(HelpshiftEvent.DATA_PUBLISH_ID);
            String type = (String) eventData.get(HelpshiftEvent.DATA_MESSAGE_TYPE);
            String body = (String) eventData.get(HelpshiftEvent.DATA_MESSAGE_BODY);
            Long createdTs = (Long) eventData.get(HelpshiftEvent.DATA_CREATED_TIME);

            // Utils.isEmpty() is null and empty Check

            if (Utils.isEmpty(publishId) && Utils.isEmpty(type) && Utils.isEmpty(body) && createdTs == null) {
              Log.d(TAG, "Received no data");
              return;
            }

            Log.d(TAG, "publishId " + publishId + " type " + type + " body " + body + " createdTs " + createdTs);
            List<Object> attachments = (List<Object>) eventData.get(HelpshiftEvent.DATA_ATTACHMENTS);

            if (Utils.isEmpty(attachments)) {
              Log.d(TAG, "No attachments received in message");
            } else {

              for (int i = 0; i < attachments.size(); i++) {
                Map<String, Object> attachment = (Map<String, Object>) attachments.get(i);

                String url = (String) attachment.get(HelpshiftEvent.DATA_URL);
                String contentType = (String) attachment.get(HelpshiftEvent.DATA_CONTENT_TYPE);
                String fileName = (String) attachment.get(HelpshiftEvent.DATA_FILE_NAME);
                Integer size = (Integer) attachment.get(HelpshiftEvent.DATA_SIZE);

                if (Utils.isEmpty(url) && Utils.isEmpty(fileName) && size == null) {
                  Log.d(TAG,"Received no data for attachment " + (i + 1));
                  continue;
                }

                if (Utils.isEmpty(url) || Utils.isEmpty(fileName) || size == null) {
                  Log.d(TAG,"Received incomplete data for attachment " + (i + 1));
                  continue;
                }

                Log.d(TAG, "Attachment No. : " + (i + 1) + ", url: " + url + ", contentType: " + contentType + ", fileName: " + fileName + ", size: " + size);
              }
            }
        }
  }});
```

### CSAT の送信イベント {#csat-submit-event}

このイベントは、会話の終了後にユーザーが CSAT（顧客満足度）評価を送信したときにトリガーされます。イベントのデータオブジェクトには`rating`キーと`additionalFeedback`キーが含まれており、これらはユーザーが CSAT フォームを介して提供した（星による）評価と追加のコメントを示しています。

- イベントの名前: `HelpshiftEvent.CSAT_SUBMIT`
- イベントのデータ:
  - `HelpshiftEvent.DATA_CSAT_RATING`
  - `HelpshiftEvent.DATA_ADDITIONAL_FEEDBACK`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CSAT_SUBMIT:
        Log.d(TAG, data.get(HelpshiftEvent.DATA_CSAT_RATING));
        Log.d(TAG, data.get(HelpshiftEvent.DATA_ADDITIONAL_FEEDBACK));
    }
  }
```

### 会話の終了イベント {#conversation-end-event}

このイベントは会話が終了（解決または拒否）し、再開できない場合にトリガーされます。

- イベントの名前: `HelpshiftEvent.CONVERSATION_END`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_END:
        //data will be empty
    }
  }
```

### 会話の拒否イベント {#conversation-rejected-event}

このイベントは、エージェントが会話を拒否したときにトリガーされます。

- イベントの名前: `HelpshiftEvent.CONVERSATION_REJECTED`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_REJECTED:
        //data will be empty
    }
  }
```

### 会話の解決イベント {#conversation-resolved-event}

このイベントは、エージェントが会話を解決したときにトリガーされます。

- イベントの名前: `HelpshiftEvent.CONVERSATION_RESOLVED`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_RESOLVED:
        //data will be empty
    }
  }
```

### 会話の再開イベント {#conversation-reopened-event}

解決に関する質問が有効化されている場合、ユーザーに対して解決の内容に満足しているかどうかが質問されます。ユーザーがそれを拒否し、新しいメッセージを送信すると会話が再開され、会話の再開イベントがトリガーされます。

- イベントの名前: `HelpshiftEvent.CONVERSATION_REOPENED`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.CONVERSATION_REOPENED:
        //data will be empty
    }
  }
```

### ユーザー認証の失敗イベント {#user-authentication-failed-event}

ダッシュボードで`User Authentication`機能が有効化された状態で`Helpshift.login(userDataMap)`で無効なトークンを渡すと、理由に関する文字列とともにこのイベントを受け取ります。詳細については、[こちらを参照してください](/sdkx_android/users)。

理由の種類:

- `HelpshiftAuthenticationFailureReason.REASON_INVALID_AUTH_TOKEN`
- `HelpshiftAuthenticationFailureReason.REASON_AUTH_TOKEN_NOT_PROVIDED`
- `HelpshiftAuthenticationFailureReason.UNKNOWN`

```java
     // ...
    Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
       @Override
      public void onUserAuthenticationFailure(HelpshiftAuthenticationFailureReason reason) {
        Log.e(TAG, reason);
      }
    }
    // ...
```

### Helpshift セッションのデリゲート {#session-delegates}

#### Helpshift セッションの開始

Helpshift セッションがアプリ内でいつ開始したかを追跡する場合は、このデリゲートコールバックを実装します。このデリゲートは、Helpshift セッションが開始するたびに発動します。

- イベントの名前: `HelpshiftEvent.SDK_SESSION_STARTED`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.SDK_SESSION_STARTED:
        //sdk session started
    }
  }
```

#### Helpshift セッションの終了

Helpshift セッションがアプリ内でいつ終了したかを追跡する場合は、このデリゲートコールバックを実装します。このデリゲートは、Helpshift セッションが終了するたびに発動します。

- イベントの名前: `HelpshiftEvent.SDK_SESSION_ENDED`

```java
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.SDK_SESSION_ENDED:
        //sdk session ended
    }
  }
```

### 未読メッセージ数の計測 {#unread-message-count}

既存の会話で受信した新規メッセージの数を計測する場合は、この`requestUnreadMessageCount(final boolean shouldFetchFromServer)` API を呼び出します。

未読メッセージの数は、このイベントを介してアプリに伝達されます。また、このイベントを使用してバッジの表示数を更新し続けることもできます。

- イベントの名前: `HelpshiftEvent.RECEIVED_UNREAD_MESSAGE_COUNT`
- イベントのデータ: `HelpshiftEvent.DATA_MESSAGE_COUNT`
  `HelpshiftEvent.DATA_MESSAGE_COUNT_FROM_CACHE`

```java
// call requestUnreadMessageCount() api first
Helpshift.requestUnreadMessageCount(true);

// ...
Helpshift.setHelpshiftEventsListener(new HelpshiftEventsListener() {
  @Override
  public void onEventOccurred(@NonNull String eventName, Map<String, Object> data) {
    switch(eventName){
      case HelpshiftEvent.RECEIVED_UNREAD_MESSAGE_COUNT:
        int count = (int) data.get(HelpshiftEvent.DATA_MESSAGE_COUNT);
        boolean fromCache = (boolean) data.get(HelpshiftEvent.DATA_MESSAGE_COUNT_FROM_CACHE);
        Log.d(TAG, "Message Count : " + count + ", From Cache: " + fromCache);
    }
  }
```

`Helpshift.requestUnreadMessageCount(true)`メソッドを呼び出すと、上記のデリゲートメソッド内のサーバーから通知の数が非同期で返されます。この通知の数は、キャッシュまたは Helpshift サーバーのいずれかから取得されます。Helpshift サーバーから取得する場合の通知数についてはレートが制限されており、タイムアウトのリセット後またはユーザーがチャット画面を閉じた後（いずれかの早い方）に API に対する次の呼び出しが行われた場合にのみ最新の値が返されます。レート制限の期間内に API が呼び出された場合には、ローカルキャッシュから値が返されます。タイムアウトのリセット時間は、アクティブな問題の場合は 1 分、そして非アクティブな問題の場合には 5 分に設定されています。

ローカルに保存されている現在の通知数を取得する場合、パラメータを false に設定した同じ`Helpshift.requestUnreadMessageCount(false)`メソッドを呼び出します。この場合、SDK はローカルで利用可能な未読メッセージの数をこのデリゲートメソッド内で返します。

ローカルに保存されている未読メッセージの数は、追加のネットワーク呼び出しを節約するのに役立ちます。
